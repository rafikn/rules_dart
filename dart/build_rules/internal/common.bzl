# Copyright 2016 The Bazel Authors. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Internal implementation utility functions for Dart rules."""

# Re-exports for backwards compatibility.
load(
    "//dart/build_rules/common:constants.bzl",
    _api_summary_extension = "api_summary_extension",
    _dart_filetypes = "dart_filetypes",
)
load(
    "//dart/build_rules/common:context.bzl",
    _collect_dart_context = "collect_dart_context",
    _make_dart_context = "make_dart_context",
)
load(
    "//dart/build_rules/common:ddc.bzl",
    _compute_ddc_output_dir = "compute_ddc_output_dir",
)
load(
    "//dart/build_rules/common:label.bzl",
   _label_to_dart_package_name = "label_to_dart_package_name",
)
load(
    "//dart/build_rules/common:path.bzl",
    _filter_files = "filter_files",
    _relative_path = "relative_path",
    _strip_extension = "strip_extension",
)

SDK_LIB_FILES = "@dart_sdk//:lib_files"

api_summary_extension = _api_summary_extension

dart_filetypes = _dart_filetypes

collect_dart_context = _collect_dart_context

make_dart_context = _make_dart_context

compute_ddc_output_dir = _compute_ddc_output_dir

label_to_dart_package_name = _label_to_dart_package_name

filter_files = _filter_files

relative_path = _relative_path

strip_extension = _strip_extension

def dartvm_target():
    return "@dart_sdk//:dart_vm"

def kernel_worker_snapshot():
    return "@dart_sdk//:kernel_worker_snapshot"

def sdk_summary_dill():
    return "@dart_sdk//:sdk_summary_dill"

def platform_summary(platforms):
    """A label for the SDK summary file.

    Today this is always the DDC SDK summary, in the future more platforms may
    be supported.
    """
    return Label("@dart_sdk//:sdk_summary")

def package_spec_action(ctx, dart_ctx, output):
    """Creates an action that generates a Dart package spec.

    Arguments:
      ctx: The rule context.
      dart_ctx: The Dart context.
      output: The output package_spec file.
    """

    # There's a 1-to-many relationship between packages and targets, but
    # collect_transitive_packages() asserts that their lib_roots are the same.
    dart_ctxs = collect_dart_context(dart_ctx).values()

    # Generate the content.
    content = "# Generated by Bazel\n"
    for dc in dart_ctxs:
        lib_root = dc.lib_root
        relative_lib_root = relative_path(dart_ctx.label.package, lib_root)
        if dc.package:
            content += "%s:%s\n" % (dc.package, relative_lib_root)

    # Emit the package spec.
    ctx.actions.write(
        output = output,
        content = content,
    )

def layout_action(ctx, srcs, output_dir):
    """Generates a flattened directory of sources.

    For each file f in srcs, a file is emitted at output_dir/f.short_path.
    Returns a dict mapping short_path to the emitted file.

    Args:
      ctx: the build context.
      srcs: the set of input srcs to be flattened.
      output_dir: the full directory path into which the files are emitted.

    Returns:
      A map from input file short_path to File in output_dir.
    """
    commands = []
    output_files = {}

    # TODO(cbracken) extract next two lines to func
    if not output_dir.endswith("/"):
        output_dir += "/"
    for src_file in srcs:
        short_better_path = src_file.short_path
        if short_better_path.startswith("../"):
            dest_file = ctx.actions.declare_file(
                output_dir + short_better_path.replace("../", ""),
            )
        else:
            dest_file = ctx.actions.declare_file(
                output_dir + short_better_path,
            )
        dest_dir = dest_file.path[:dest_file.path.rfind("/")]
        link_target = relative_path(dest_dir, src_file.path)
        commands += ["ln -s '%s' '%s'" % (link_target, dest_file.path)]
        output_files[src_file.short_path] = dest_file

    # Emit layout script.
    layout_cmd = ctx.actions.declare_file(ctx.label.name + "_layout.sh")
    ctx.actions.write(
        output = layout_cmd,
        content = "#!/bin/bash\n" + "\n".join(commands),
        is_executable = True,
    )

    # Invoke the layout action.
    ctx.actions.run(
        inputs = list(srcs),
        outputs = output_files.values(),
        executable = layout_cmd,
        progress_message = "Building flattened source layout for %s" % ctx,
        mnemonic = "DartLayout",
    )
    return output_files

# Check if `srcs` contains at least some dart files
def has_dart_sources(srcs):
    for n in srcs:
        if n.path.endswith(".dart"):
            return True
    return False

def make_package_uri(dart_ctx, short_path, prefix = ""):
    if short_path.startswith("../"):
        short_path = short_path.replace("../", "")
    if short_path.startswith(dart_ctx.lib_root):
        return "package:%s/%s" % (
            dart_ctx.package,
            short_path[len(dart_ctx.lib_root):],
        )
    else:
        return "file:///%s%s" % (prefix, short_path)

def compute_layout(srcs):
    """Computes a dict mapping short_path to file.

    This is similar to the dict returned by layout_action, except that
    the files in the dict are the original files rather than symbolic
    links.
    """
    output_files = {}
    for src_file in srcs:
        output_files[src_file.short_path] = src_file
    return output_files
